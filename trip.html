
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="title">Zuginformationen</title>
    <link rel="stylesheet" href="./assets/css/styles.css">
    <link rel="stylesheet" href="./assets/css/dark-styles.css">
    <link rel="stylesheet" href="./assets/css/line-colors.css">
    <link rel="shortcut icon" type="image/x-icon" href="./assets/branding/favicon.ico">
    <link rel="manifest" href="/manifest.json" type="application/json">
    <meta name="theme-color" content="#000">
    <meta name="robots" content="noindex">

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.js"></script>
</head>

<body class="trip-body">

    <noscript> You need to enable JavaScript to run this app.</noscript>

    <div id="map"></div>

    <div class="TRIPcontent">
    <center>
    <div class="coloredSpace" id="bigheaderbox">
        <div class="darker">
            <div class="dragbar"></div>
            <div class="blanktable">
                <div class="tripcontainer wide">

                    <table class="wide"><tr><td><div class="smallBadge whiteBadge" id="linebadge"></div></td><td style="padding-top: 4px; padding-left: 4px;"><span id="trainTitle"></span></td><td class="wide"></td><td><a href="#" onclick="history.go(-1)" style="padding: 0px !important;"><img src="./assets/icons/close.svg" class="mediumicon"></a></td></tr></table>
                    <small class="disabled" id="operatorName"></small><br><small class="disabled" id="trip-date"></small>
                    
                    
                </div>
            </div>
        </div>
    </div>

    <div class="station-container">
        <div class="station"><span id="originStation"></span></div>
        <div class="arrow-circle">‚Ä¢‚ñ∫</div>
        <div class="station"><span id="destinationStation"></span></div>
    </div>

    <div class="displayflex actiontable" id="pinDiv">
        <div class="actiontableelement"><img src="./assets/icons/addtrain.png" id="addtrainIcon" class="inverted noinvert actionicon"></div>
        <div class="actiontableelement"><span id="pinIt">Anheften</span></div>
    </div>

    <a href="https://www.bahn.de/buchung/jetzt-einchecken?dbkanal_007=tutorialSlider_14-1_link_KomfortCheckinimBrowseraufrufen">
        <div class="displayflex actiontable hidden" id="comfortbutton">
            <div class="actiontableelement"><img src="./assets/icons/comfortcheckin.svg" class="inverted noinvert actionicon"></div>
            <div class="actiontableelement"><span id="pinIt">Jetzt einchecken</span></div>
        </div>
    </a>
    <a id="wagonorderbutton">
        <div class="displayflex actiontable">
            <div class="actiontableelement"><img src="./assets/icons/wagonorder.svg" class="inverted noinvert actionicon"></div>
            <div class="actiontableelement"><span id="pinIt">Wagenreihung</span></div>
        </div>
    </a>

    <a href="#remarks">
        <div class="displayflex actiontable">
            <div class="actiontableelement"><img src="./assets/icons/arrow.svg" class="actionicon" id="warningicon"></div>
            <div class="actiontableelement"><span id="trip-warning-counter-button">Keine</span>&nbsp;<span id="pinIt">akuelle Informationen</span></div>
        </div>
    </a>

    <div class="coloredSpace displayflex center">

    </div>


    <div class="trip-container-centered">

        <div class="trip-status-container"></div>
        <!-- Header der Seite mit Zugdetails -->



        <!-- Modal -->

        <div class="secondary" id="tripStatus"><img src="./assets/blackSpinner.svg" class="loadingspinner multicolorspinner"></div>
    </div>
    

    <!-- Liste der Haltestellen -->
    <div class="trip-stopovers">
        <!-- Dynamisch generierte Stopover-Elemente werden hier eingef√ºgt -->
    </div>

    <!-- Warnungen und Hinweise -->

    <div class="gray smaller" id="remarks">
        <table id="remarksTable" cellpadding="10"></table>

        <br>
    </div>

    <br>

    <small>Datenquelle:</small><br>
    <span id="logo"></span>



    <br><br><br>
    </center>
    </div>
</div>







<script>

    window.scroll({
      top: 300,
      behavior: "smooth",
    });

    // Funktion, um Parameter aus der URL zu extrahieren
    function getParameterByName(name, url = window.location.href) {
        name = name.replace(/[\[\]]/g, '\\$&');
        const regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
        const results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
    }

    let map;
    let marker;
    let intervalId;

    // Funktion zur Aktualisierung der aktuellen Position auf der Karte
    async function updateCurrentPosition(tripId) {
        let tripApiUrl = `https://data.cuzimmartin.dev/dynamic-trip?tripId=${encodeURIComponent(tripId)}&stationID=${stationId}`;
        tripResponse = await fetch(tripApiUrl);

        const tripData = await tripResponse.json();

        if (tripData.trip.currentLocation && marker) {
            const newPosition = [tripData.trip.currentLocation.longitude, tripData.trip.currentLocation.latitude];
            marker.setLngLat(newPosition);
        }
    }

    // Funktion zum Initialisieren der Karte
    async function fetchAndDisplayMapData() {
        const tripId = decodeURIComponent(getParameterByName('tripId'));
        const stationId = getParameterByName('stationID');

        if (!tripId) {
            alert("Keine tripId in der URL gefunden.");
            return;
        }


        let polylineApiUrl = `https://data.cuzimmartin.dev/trip/${encodeURIComponent(tripId)}/polyline?stationID=${stationId}`;       
        let polylineResponse;
        polylineResponse = await fetch(polylineApiUrl);
        const polylineData = await polylineResponse.json();

    

    let tripApiUrl = `https://data.cuzimmartin.dev/dynamic-trip?tripId=${encodeURIComponent(tripId)}&stationID=${stationId}`;
    let tripResponse;
    tripResponse = await fetch(tripApiUrl);
    const tripData = await tripResponse.json();

    // Bestimmen der Startposition aus den Polyline-Daten
    let startPosition = [16.3738, 48.2082]; // Standardposition
    if (polylineData.polyline && polylineData.polyline.features && polylineData.polyline.features.length > 0) {
        const firstFeature = polylineData.polyline.features[0];
        if (firstFeature.geometry.type === "Point") {
            startPosition = [firstFeature.geometry.coordinates[0], firstFeature.geometry.coordinates[1]];
        }
    }

    mapboxgl.accessToken = 'pk.eyJ1IjoibWFydGlpbmhpZXIiLCJhIjoiY2x6b284ZGxtMHRlbzJpcjd5em80MDIxcSJ9.BMb9-B_QvsdFy6arQxennw';
    map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/dark-v10',
        center: startPosition,
        zoom: 10
    });

    if (polylineData.polyline && polylineData.polyline.features) {
        const coordinates = polylineData.polyline.features.map(feature => {
            if (feature.geometry.type === "Point") {
                return [feature.geometry.coordinates[0], feature.geometry.coordinates[1]];
            }
        }).filter(coord => coord);

        const fullRoute = {
            'type': 'Feature',
            'geometry': {
                'type': 'LineString',
                'coordinates': coordinates
            }
        };

        map.on('load', () => {

            
            // F√ºge die Route als Layer hinzu
            map.addSource('fullRoute', {
                'type': 'geojson',
                'data': fullRoute
            });
            

            map.addLayer({
                'id': 'fullRoute',
                'type': 'line',
                'source': 'fullRoute',
                'layout': {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                'paint': {
                    'line-color': '#ffffff',
                    'line-width': 4
                }
            });

            // Erstelle eine Quelle f√ºr die Stopps
            const stopFeatures = polylineData.polyline.features
                .filter(feature => feature.geometry.type === 'Point' && feature.properties.type === 'stop')
                .map(feature => ({
                    type: 'Feature',
                    geometry: feature.geometry,
                    properties: {
                        description: feature.properties.name || 'Unbekannter Halt',
                    }   
                }));


                

            // Wenn Stopps vorhanden sind, f√ºge sie als Quelle und Layer hinzu
            if (stopFeatures.length > 0) {
                map.addSource('stops', {
                    'type': 'geojson',
                    'data': {
                        'type': 'FeatureCollection',
                        'features': stopFeatures
                    }
                });

                map.addLayer({
                    'id': 'poi-labels',
                    'type': 'symbol',
                    'source': 'stops',
                    'layout': {
                        'text-field': ['get', 'description'],
                        'text-variable-anchor': ['left'],
                        'text-radial-offset': 1,
                        'text-justify': 'auto'
                        
                    },
                    'paint': {
                        'text-color': '#fff'
                    }

                    
                });
            }



            // Iteriere durch die Features, um Marker f√ºr Stopps hinzuzuf√ºgen
            polylineData.polyline.features.forEach(feature => {
                if (feature.geometry.type === "Point" && feature.properties.type === "stop") {
                    const stopPosition = feature.geometry.coordinates;

                    // Erstelle einen Marker mit einem anderen Stil f√ºr Stops
                    const stopMarker = document.createElement('img');
                    stopMarker.src = './assets/icons/stop-marker.svg'; // anderes Icon f√ºr Stopps
                    stopMarker.style.width = '10px'; // Breite des Stop-Markers
                    stopMarker.style.height = '10px'; // H√∂he des Stop-Markers

                    // Marker mit dem Bild erstellen und hinzuf√ºgen
                    new mapboxgl.Marker({
                        element: stopMarker // Das Bild als Marker verwenden
                    })
                        .setLngLat(stopPosition) // Position des Markers setzen
                        .addTo(map); // Marker zur Karte hinzuf√ºgen
                }
            });

            // Marker f√ºr den Standort des Zuges hinzuf√ºgen
            if (tripData.trip.currentLocation) {
                const currentLocation = [tripData.trip.currentLocation.longitude, tripData.trip.currentLocation.latitude];

                // Bild-Element f√ºr den Zug-Standort
                const imageMarker = document.createElement('img');
                imageMarker.src = './assets/icons/mapmarker.svg'; // Hier das Icon f√ºr den Zugstandort
                imageMarker.style.width = '40px'; // Breite des Bildes anpassen
                imageMarker.style.height = '40px'; // H√∂he des Bildes anpassen

                // Marker f√ºr den Zugstandort
                marker = new mapboxgl.Marker({
                    element: imageMarker // Das Bild als Marker verwenden
                })
                    .setLngLat(currentLocation) // Position des Markers setzen
                    .addTo(map); // Marker zur Karte hinzuf√ºgen
            } else {
                console.warn("Aktuelle Position nicht verf√ºgbar, Marker wird nicht gesetzt.");
            }

            const bounds = coordinates.reduce(function (bounds, coord) {
                return bounds.extend(coord);
            }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));

            map.fitBounds(bounds, {
                padding: {top: 50, bottom: 50, left: 50, right: 50}
            });

            if (tripData.trip.currentLocation) {
                intervalId = setInterval(() => updateCurrentPosition(tripId), 10000);
            }
        });
    } else {
        console.error("Keine g√ºltigen Polyline-Daten gefunden");
    }
}

fetchAndDisplayMapData();


    async function fetchAndDisplayData() {
        const currentUrl = window.location.href;

        const tripId = decodeURIComponent(getParameterByName('tripId', currentUrl));
        stationId = getParameterByName('stationID', currentUrl);

      

        let data;


        if (stationId !== null) {
            let apiUrl = `https://data.cuzimmartin.dev/dynamic-trip?tripId=${encodeURIComponent(tripId)}&stationID=${stationId}`;
            let response = await fetch(apiUrl);
            data = await response.json();
            profileUsed = 'dynamic';
        } 
        
        document.getElementById('logo').innerHTML = `<img src="./assets/providerLogos/${data.provider}.svg" class="trip-logo" title="Die Datenquelle steht in keinerlei Verbindung mit diesem Projekt. Die Daten k√∂nnen Fehler aufweisen.">`;

       
        if (!data) {

            console.error('Fehler beim Abrufen der Trip-Daten.');
            const statusElement = document.getElementById('tripStatus');
            document.body.innerHTML= `
                <nav id="navbar">
                    <div class="tabs"><span class="active">&nbsp;Zuginformationen&nbsp;</span></div>
                    <div class="iconbar bigonly"><a href="#" onclick="history.go(-1)">Schlie√üen</a></div>
                    <div class="iconbar"><a href="#" onclick="history.go(-1)"><img src="./assets/icons/close.svg" class="mediumicon"></a></div>
                </nav>

                <center>
                <br><br>
                <h1>‚õìÔ∏è‚Äçüí•</h1>
                <h3>Fehler beim Abrufen der Daten</h3>

                <p>Dieser Link ist ung√ºltig oder deine Internet-Verbindung wurde unterbrochen.</p>

                <br>

                <div onClick=\"history.go(0)\" class="button reload">Erneut laden</div>

            `;
            return;
        }


        // Funktion zur Aktualisierung des Zugstatus
        function updateTrainStatus(trip) {
            let currentTime = new Date();
            let departureTime = trip.departure ? new Date(trip.departure) : null;
            let arrivalTime = trip.arrival ? new Date(trip.arrival) : null;

            const statusElement = document.getElementById('tripStatus');

            // Funktion zur Formatierung der Zeitangabe
            function formatTimeDifference(timeDiffMillis) {
                const totalMinutes = Math.round(timeDiffMillis / 60000);
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;

                let timeString = '';
                if (hours > 0) {
                    timeString = `${hours} Stunde${hours > 1 ? 'n' : ''}`;
                    if (minutes > 0) {
                        timeString += ` und ${minutes} Minute${minutes !== 1 ? 'n' : ''}`;
                    }
                } else {
                    timeString = `${minutes} Minute${minutes !== 1 ? 'n' : ''}`;
                }

                return timeString;
            }

            // Hilfsfunktion zur Generierung des Plattform-Strings
            function getPlatformInfo(platform) {
                return platform ? `auf Gleis ${platform}` : 'ohne festgelegtes Gleis';
            }

            // Pr√ºfen, ob der gesamte Zug storniert wurde
            const isTripCancelled = trip.cancelled === true;

            // Pr√ºfen, ob alle Stopovers storniert wurden
            const allStopoversCancelled = trip.stopovers.every(stop => stop.cancelled === true);

            // Wenn der Zug vollst√§ndig storniert wurde
            if (isTripCancelled && allStopoversCancelled) {
                statusElement.innerHTML = `${trip.line.name} ist vollst√§ndig ausgefallen.`;
                return;
            }

            // Wenn der Zug teilweise storniert wurde
            const cancelledStopovers = trip.stopovers.filter(stop => stop.cancelled === true);
            const activeStopovers = trip.stopovers.filter(stop => !stop.cancelled);

            // Funktion zum Finden des n√§chsten aktiven Stopovers
            function findNextActiveStopover() {
                for (let i = 0; i < activeStopovers.length; i++) {
                    const stop = activeStopovers[i];
                    const plannedDeparture = stop.plannedDeparture ? new Date(stop.plannedDeparture) : null;
                    const actualDeparture = stop.departure ? new Date(stop.departure) : null;

                    if ((plannedDeparture && plannedDeparture > currentTime) || (actualDeparture && actualDeparture > currentTime)) {
                        return stop;
                    }
                }
                return null;
            }

            // Wenn der Zug noch nicht abgefahren ist
            if (departureTime && currentTime < departureTime && !trip.origin.cancelled) {
                const timeUntilDeparture = departureTime - currentTime;
                const timeString = formatTimeDifference(timeUntilDeparture);

                const platformInfo = getPlatformInfo(trip.departurePlatform || trip.plannedDeparturePlatform);

                statusElement.innerHTML = `${trip.line.name} f√§hrt in ${timeString} von <b class="markedstation">${trip.origin.name}</b> ${platformInfo} ab.`;
                return;
            }

            // Wenn der Zug bereits abgefahren ist oder der Abfahrtsbahnhof storniert wurde
            let nextStop = findNextActiveStopover();

            if (nextStop) {
                const arrivalTimeAtNextStop = nextStop.arrival ? new Date(nextStop.arrival) : new Date(nextStop.plannedArrival);
                const timeUntilNextStop = arrivalTimeAtNextStop - currentTime;
                const timeString = formatTimeDifference(timeUntilNextStop);

                const platformInfoArrival = getPlatformInfo(nextStop.arrivalPlatform || nextStop.plannedArrivalPlatform);
                const platformInfoDeparture = getPlatformInfo(nextStop.departurePlatform || nextStop.plannedDeparturePlatform);

                if (timeUntilNextStop > 0) {
                    // Zug erreicht bald den n√§chsten Halt
                    statusElement.innerHTML = `${trip.line.name} erreicht in ${timeString} <b class="markedstation">${nextStop.stop.name}</b> ${platformInfoArrival}.`;
                } else {
                    // Zug ist bereits am n√§chsten Halt angekommen
                    const departureTimeAtNextStop = nextStop.departure ? new Date(nextStop.departure) : new Date(nextStop.plannedDeparture);
                    const timeUntilDeparture = departureTimeAtNextStop - currentTime;

                    if (timeUntilDeparture > 0) {
                        const departureTimeString = formatTimeDifference(timeUntilDeparture);

                        statusElement.innerHTML = `${trip.line.name} steht aktuell in <b class="markedstation">${nextStop.stop.name}</b> und f√§hrt in ${departureTimeString} ${platformInfoDeparture} ab.`;
                    } else {
                        statusElement.innerHTML = `${trip.line.name} hat <b class="markedstation">${nextStop.stop.name}</b> gerade verlassen und ist auf dem Weg zum n√§chsten Halt.`;
                    }
                }
            } else {
                // Wenn kein weiterer aktiver Halt mehr bevorsteht
                if (arrivalTime && currentTime >= arrivalTime && !trip.destination.cancelled) {
                    statusElement.innerHTML = `${trip.line.name} hat sein Ziel <b class="markedstation">${trip.destination.name}</b> erreicht.`;
                } else if (trip.destination.cancelled) {
                    statusElement.innerHTML = `${trip.line.name} endet vorzeitig und erreicht nicht sein geplantes Ziel.`;
                } else {
                    const timeUntilArrival = arrivalTime ? arrivalTime - currentTime : null;
                    const timeString = timeUntilArrival ? formatTimeDifference(timeUntilArrival) : 'unbekannter Zeit';

                    const platformInfo = getPlatformInfo(trip.arrivalPlatform || trip.plannedArrivalPlatform);

                    statusElement.innerHTML = `${trip.line.name} ist auf dem Weg zu seinem Endziel <b class="markedstation">${trip.destination.name}</b> und wird in ${timeString} ${platformInfo} ankommen.`;
                }
            }

            // Hinweis auf ausgefallene Halte
            if (cancelledStopovers.length > 0) {
                const cancelledStopsNames = cancelledStopovers.map(stop => stop.stop.name).join(', ');
                statusElement.innerHTML += `\nDie folgenden Halte entfallen: ${cancelledStopsNames}.`;
            }
        }

        if ((data.trip.line.productName === 'ICE') || (data.trip.line.productName === 'IC')) {
            document.getElementById('comfortbutton').classList.remove('hidden');
        }

        // Titel und Details setzen
        document.getElementById('trainTitle').innerHTML = `(${data.trip.line.fahrtNr})`;

        var lineName = data.trip.line.name.split('(')[0];
        document.getElementById('linebadge').innerHTML = `${lineName}`;

        document.getElementById('operatorName').innerHTML = `${data.trip.line.operator.name}`;

        document.getElementById('title').innerHTML = `${data.trip.line.productName} ${data.trip.line.fahrtNr} ü°∫ ${data.trip.destination.name}`;

        // Dauer berechnen
        const departureTime = new Date(data.trip.plannedDeparture);


        // Datum setzen
        const tripDate = departureTime.toLocaleDateString('de-DE', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
        document.getElementById('trip-date').innerHTML = tripDate;

        // Ursprungsstation und Zielstation setzen
        document.getElementById('originStation').textContent = data.trip.origin.name;

        document.getElementById('destinationStation').textContent = data.trip.destination.name;


        // Funktion zur Bestimmung des Haltestellenstatus
        function getStopStatus(stop, currentTime, isLastStop) {
            if (stop.cancelled) {
                return 'cancelled';
            }

            const plannedArrival = stop.plannedArrival ? new Date(stop.plannedArrival) : null;
            const actualArrival = stop.arrival ? new Date(stop.arrival) : null;
            const plannedDeparture = stop.plannedDeparture ? new Date(stop.plannedDeparture) : null;
            const actualDeparture = stop.departure ? new Date(stop.departure) : null;

            const arrivalTime = actualArrival || plannedArrival;
            const departureTime = actualDeparture || plannedDeparture;

            // Wenn es sich um die Endhaltestelle handelt und die Ankunftszeit vergangen ist, setze den Status auf 'past'
            if (isLastStop && arrivalTime && arrivalTime < currentTime) {
                return 'past';
            }

            if (departureTime && departureTime < currentTime) {
                return 'past';
            } else if (!stop.nextToCurrent && arrivalTime && arrivalTime > currentTime) {
                return 'future';
            } else {
                return 'unknown';
            }
        }

// Haltestellen dynamisch hinzuf√ºgen
        const stopoversContainer = document.querySelector('.trip-stopovers');
        stopoversContainer.innerHTML = '';

        const currentTime = new Date(); // Aktuelle Zeit

        let currentStopFound = false;

        data.trip.stopovers.forEach((stop, index) => {
            const stopElement = document.createElement('div');
            stopElement.classList.add('trip-stopover');

            const isLastStop = index === data.trip.stopovers.length - 1;
            let stopStatus = getStopStatus(stop, currentTime, isLastStop);

            if (!currentStopFound && stopStatus === 'future') {
                // Setze die erste zuk√ºnftige Haltestelle als 'current'
                stopStatus = 'current';
                

                // Berechne den Fortschrittsprozentsatz basierend auf der Abfahrtszeit der vorherigen Haltestelle
                // Falls es keine vorherige Haltestelle gibt, setze den Fortschritt auf 0%
                let progressPercentage = 0;

                if (index > 0) {
                    const previousStop = data.trip.stopovers[index - 1];
                    const previousDepartureTime = previousStop.departure ? new Date(previousStop.departure) : new Date(previousStop.plannedDeparture);
                    const arrivalTime = stop.arrival ? new Date(stop.arrival) : new Date(stop.plannedArrival);
                    const departureTime = stop.departure ? new Date(stop.departure) : new Date(stop.plannedDeparture);

                    const totalTime = arrivalTime - previousDepartureTime;
                    const timePassed = currentTime - previousDepartureTime;

                    progressPercentage = (timePassed / totalTime) * 100;
                    progressPercentage = Math.min(Math.max(progressPercentage, 0), 100); // Begrenze zwischen 0% und 100%
                }

                // Setze die CSS-Variable mit dem Fortschrittsprozentsatz
                stopElement.style.setProperty('--progress-percentage', `${progressPercentage}%`);
                stopElement.style.setProperty('--progress-px', `${40 / 100 * (progressPercentage - 1) - 45}px`);
                stopElement.innerHTML = `
                <picture>
                    <source srcset="./assets/icons/train-top-dark.svg" media="(prefers-color-scheme: dark)">
                    <source srcset="./assets/icons/train-top.svg" media="(prefers-color-scheme: light)">
                    <img src="./assets/icons/train-top.svg" alt="Location" class="trainposition">
                </picture>
                `;

            }

            // F√ºge eine Klasse basierend auf dem Status hinzu
            stopElement.classList.add(`stop-${stopStatus}`);
            

            // Generiere den Inhalt der Haltestelle
            if (stop.cancelled) {
                stopElement.innerHTML += `
            
            <div class="trip-stop-time">
                <div class="trip-delay" style="font-size: 16px">Entf√§llt</div>
            </div>
            <div class="trip-stop-info">
                <span class="trip-stop-name">${stop.stop.name}</span>
            </div>
            <div class="connection-cell">
                &nbsp;
            </div>
        `;
            } else if (stopStatus === 'current') {

                currentStopFound = true;

                const plannedArrivalTime = stop.plannedArrival ? new Date(stop.plannedArrival).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const actualArrivalTime = stop.arrival ? new Date(stop.arrival).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const plannedDepartureTime = stop.plannedDeparture ? new Date(stop.plannedDeparture).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const actualDepartureTime = stop.departure ? new Date(stop.departure).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';

                const arrivalTimeDisplay = plannedArrivalTime === actualArrivalTime || !actualArrivalTime ? plannedArrivalTime : `<s class="disabled">${plannedArrivalTime}</s>&nbsp;<span>${actualArrivalTime}</span>`;
                const departureTimeDisplay = plannedDepartureTime === actualDepartureTime || !actualDepartureTime ? plannedDepartureTime : `<s class="disabled">${plannedDepartureTime}</s>&nbsp;<span>${actualDepartureTime}</span>`;

                let stopname = stop.stop.name;
                if (stationId === stop.stop.id) {
                    stopElement.classList.add('marked-stopover');
                }

                stopElement.innerHTML += `
                
            <div class="trip-stop-time">
                <div>${arrivalTimeDisplay}</div>
                <div>${departureTimeDisplay}</div>
            </div>
            <div class="trip-stop-info">
                <span class="trip-stop-name">${stopname}</span>
                <span class="trip-platform">${(stop.arrivalPlatform || stop.departurePlatform) ? `Gl&nbsp;${stop.arrivalPlatform || stop.departurePlatform}` : '-'}</span>
            </div>
            <div class="connection-cell">
                ${stop.arrival !== null ? `<a href="connections.html?stop=${stop.stop.location.id}&tripID=${encodeURIComponent(tripId)}">&nbsp;<img src="./assets/icons/connectingTrain.svg"></a>` : '&nbsp;<img src="./assets/icons/placeholder.svg">'}
            </div>
        `;


            } else {
                const plannedArrivalTime = stop.plannedArrival ? new Date(stop.plannedArrival).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const actualArrivalTime = stop.arrival ? new Date(stop.arrival).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const plannedDepartureTime = stop.plannedDeparture ? new Date(stop.plannedDeparture).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const actualDepartureTime = stop.departure ? new Date(stop.departure).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';

                const arrivalTimeDisplay = plannedArrivalTime === actualArrivalTime || !actualArrivalTime ? plannedArrivalTime : `<s class="disabled">${plannedArrivalTime}</s>&nbsp;<span>${actualArrivalTime}</span>`;
                const departureTimeDisplay = plannedDepartureTime === actualDepartureTime || !actualDepartureTime ? plannedDepartureTime : `<s class="disabled">${plannedDepartureTime}</s>&nbsp;<span>${actualDepartureTime}</span>`;

                let stopname = stop.stop.name;
                if (stationId === stop.stop.id) {
                    stopElement.classList.add('marked-stopover');
                }

                stopElement.innerHTML += `
                
            <div class="trip-stop-time">
                <div>${arrivalTimeDisplay}</div>
                <div>${departureTimeDisplay}</div>
            </div>
            <div class="trip-stop-info">
                <span class="trip-stop-name">${stopname}</span>
                <span class="trip-platform">${(stop.arrivalPlatform || stop.departurePlatform) ? `Gl&nbsp;${stop.arrivalPlatform || stop.departurePlatform}` : '-'}</span>
            </div>
            <div class="connection-cell">
                ${stop.arrival !== null ? `<a href="connections.html?stop=${stop.stop.location.id}&tripID=${encodeURIComponent(tripId)}">&nbsp;<img src="./assets/icons/connectingTrain.svg"></a>` : '&nbsp;<img src="./assets/icons/placeholder.svg">'}
            </div>
        `;
            }

            stopoversContainer.appendChild(stopElement);
        });


        // Wagenreihungsbutton
        var wagonorderbutton = document.getElementById('wagonorderbutton');

        var test = '2';
        // Setze das href-Attribut

        const tripdepartureTime = new Date(new URLSearchParams(window.location.search).get('departureTime')).toISOString();


        if ((stationId === null) || tripdepartureTime === null) {
            var choosenstation = data.trip.stopovers[0].stop.id;
            const tripdepartureTime = data.trip.stopovers[0].plannedDeparture;
        } else {
            var choosenstation = stationId;
            const tripdepartureTime = new URLSearchParams(window.location.search).get('departureTime');
        }


        if (wagonorderbutton) {
            wagonorderbutton.href = `wagonorder.html?trainnumber=${data.trip.line.fahrtNr}&station=${choosenstation}&producttype=${data.trip.line.productName}&departure=${tripdepartureTime}`;
        }

        // Funktion zum Entfernen von HTML-Tags aus Text (ohne Ver√§nderung der Gro√ü-/Kleinschreibung)
        function sanitizeText(text) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;
            return tempDiv.textContent || tempDiv.innerText || '';
        }

        // Funktion zum Entfernen von HTML-Tags und Normalisieren des Textes f√ºr Vergleichszwecke
        function sanitizeAndNormalizeText(text) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;
            let sanitizedText = tempDiv.textContent || tempDiv.innerText || '';
            // Konvertiere zu Kleinbuchstaben und entferne f√ºhrende/trailing Leerzeichen
            sanitizedText = sanitizedText.toLowerCase().trim();
            // Ersetze mehrere Leerzeichen durch ein einzelnes
            sanitizedText = sanitizedText.replace(/\s+/g, ' ');
            // Optional: Ersetze Zahlen durch Platzhalter, um √§hnliche Warnungen zu erkennen
            sanitizedText = sanitizedText.replace(/\d+/g, '#');
            return sanitizedText;
        }


        // Warnungen dynamisch hinzuf√ºgen
        const warningsList = document.getElementById('remarksTable');
        warningsList.innerHTML = '';

        const warningCounterElement = document.getElementById('trip-warning-counter-button');

        // Sammle die Remarks der Station
        let stationRemarks = [];
        if (stationId) {
            const stationStopover = data.trip.stopovers.find(stopover => stopover.stop.id === stationId);
            if (stationStopover && stationStopover.remarks && stationStopover.remarks.length > 0) {
                stationRemarks = stationStopover.remarks;
            }
        }

        // Sammle die Remarks des Trips
        const tripRemarks = data.trip.remarks || [];

        // Kombiniere die Remarks, wobei die der Station zuerst kommen
        const combinedRemarks = [...stationRemarks, ...tripRemarks];

        if (combinedRemarks.length > 0) {

            document.getElementById('warningicon').src = './assets/icons/warning.svg';

            const uniqueMessages = new Set();
            const uniqueRemarks = [];

            combinedRemarks.forEach(remark => {
                const normalizedText = sanitizeAndNormalizeText(remark.text);
                // Check ob remark.code definiert ist
                let code = 'default';
                if (remark.code) {
                    code = sanitizeText(remark.code.replace(/\./g, ''));
                }
                if (!uniqueMessages.has(normalizedText)) {
                    uniqueMessages.add(normalizedText);
                    uniqueRemarks.push({...remark, code});
                }
            });

            const warningCount = uniqueRemarks.length;

            // Aktualisiere den Warnungsz√§hler oben
            warningCounterElement.innerHTML = `${warningCount}`;
            

            const WarningHeaderItem = document.createElement('tr');
            WarningHeaderItem.innerHTML = `<td colspan="2"><h3><span class=\"pill\">&nbsp;&nbsp;${warningCount}&nbsp;&nbsp;</span> aktuelle Informationen:</h3></td>`;
            warningsList.appendChild(WarningHeaderItem);

            uniqueRemarks.forEach(remark => {
                const warningItem = document.createElement('tr');
                const code = remark.code || 'default';
                warningItem.innerHTML += (`<td class="clear"><img src="./assets/icons/remark${code}.svg" class="serviceicon"></td><td class="clear wide">${sanitizeText(remark.text)}</td>`);
                warningsList.appendChild(warningItem);
                
            });
        } else {
            // Aktualisiere den Warnungsz√§hler oben
            warningCounterElement.innerHTML = '&nbsp;Keine&nbsp;';

           document.getElementById('remarks').classList.add('hidden');

        }


        // Dynamischen Status des Zuges setzen
        updateTrainStatus(data.trip);

        // Header Farbe
        const badgeClassProductName = encodeURIComponent(data.trip.line.productName);
        const badgeClassProduct = encodeURIComponent(data.trip.line.product);
        const badgeClassLineOperator = encodeURIComponent(lineName.replace(/\s+/g, '')) + encodeURIComponent(data.trip.line.operator.id);
        const badgeClassOperator = encodeURIComponent(data.trip.line.operator.id);
        const tripID = encodeURIComponent(data.trip.id);

        document.getElementById('bigheaderbox').classList.add(badgeClassProductName);
        document.getElementById('bigheaderbox').classList.add(badgeClassProduct);
        document.getElementById('bigheaderbox').classList.add(badgeClassLineOperator);
        document.getElementById('bigheaderbox').classList.add(badgeClassOperator);

        document.getElementById('linebadge').classList.add(badgeClassProductName);
        document.getElementById('linebadge').classList.add(badgeClassProduct);
        document.getElementById('linebadge').classList.add(badgeClassLineOperator);
        document.getElementById('linebadge').classList.add(badgeClassOperator);

        let $number = encodeURIComponent(data.trip.id);


        // Funktion, um ein Cookie zu setzen
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/";
        }

        // Funktion, um ein Cookie abzurufen
        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        // Funktion beim Klick auf das Div
        document.getElementById('pinDiv').addEventListener('click', function () {
            // Setze das Cookie
            setCookie('pinnedjourney', $number, 7); // Cookie f√ºr 7 Tage speichern
            setCookie('pinnedjourneyStation', stationId , 7);
            document.getElementById("pinIt").textContent = "Angeheftet";
            document.getElementById("addtrainIcon").src = "./assets/icons/addedtrain.svg";
        });

        // Rufe das Cookie ab
        const tripCookieValue = getCookie('pinnedjourney');

        const stationCookieValue = getCookie('pinnedjourneyStation');

        
        

        const activeValue = `${encodeURIComponent(tripId)}`;


        if (tripCookieValue === activeValue) {
            console.log('It is pinned Journey');
            document.getElementById("pinIt").textContent = "Angeheftet";
            document.getElementById("addtrainIcon").src = "./assets/icons/addedtrain.svg";

        } else {
            console.log('It is not pinned Journey');
        }
    }

    // Event-Handler f√ºr das √ñffnen und Schlie√üen des Modals
    document.addEventListener('DOMContentLoaded', function () {

        // Rufe fetchAndDisplayData auf
        fetchAndDisplayData();

        // Alle 30 Sekunden die Daten aktualisieren
        setInterval(fetchAndDisplayData, 30000); // 30 Sekunden in Millisekunden
    });

    fetchAndDisplayData();



</script>
</body>
</html>